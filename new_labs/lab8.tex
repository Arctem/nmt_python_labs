% LAB 8: Advanced Functions
% 
% CSE/IT 107: Introduction to Programming
% New Mexico Tech
% 
% Prepared by Russell White and Christopher Koch
% Fall 2014
\documentclass[11pt]{cselabheader}
\usepackage{IEEEtrantools}

%%%%%%%%%%%%%%%%%% SET TITLES %%%%%%%%%%%%%%%%%%%%%%%%%
\fancyhead[R]{Lab 8: Advanced Functions}
\title{Lab 8: Advanced Functions}

\begin{document}

\maketitle

\hrule
\begin{quotation}
``All thought is a kind of computation.''
\end{quotation}
\begin{flushright}
--- D. Hobbes
\end{flushright}

\begin{quotation}
``Vague and nebulous is the beginning of all things, but not their end.''
\end{quotation}
\begin{flushright}
--- K. Gibran
\end{flushright}

\begin{quotation}
``It [programming] is the only job I can think of where I get to be both an
engineer and artist. There's an incredible, rigorous, technical element to it,
which I like because you have to do very precise thinking. On the other hand, it
has a wildly creative side where the boundaries of imagination are the only real
limitation.''
\end{quotation}
\begin{flushright}
--- A. Hertzfeld
\end{flushright}

\hrule

\section{Introduction}


\pagebreak
\section{Advanced Functions}
\label{sec:advfun}

\subsection{Default Arguments}
\label{subsec:arg}
Many of the built-in functions we have been using, such as \lstinline{range} or \lstinline{input}, accept a variable number of arguments. We can do the same thing with our own funcitions by specifying default values for our arguments:

\begin{lstlisting}[style=python]
def celebrate(times=1):
    for i in range(times):
        print("Yay!")

print("First call:")
celebrate()
print("Second call:")
celebrate(5)
\end{lstlisting}

Note what happens for each call of this function. The first time it only prints \lstinline{"Yay!"} once, since the default argument is \lstinline{1}, while the second call overwrites the default value and prints it five times.

While you are allowed to have a function that has some arguments with default values and some without, you must always put those with default values after those without any, so that Python will know which arguments go into which values if you don't include all of them when calling the function:

\begin{lstlisting}[style=ipython]
>>> def test(a, b=5, c, d=6):
...   print(a, b, c, d)
... 
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument
>>> def test(a, c, b=5, d=6):
...   print(a, b, c, d)
... 
>>> test(2, 3)
2 5 3 6
>>> test(2, 3, 10)
2 10 3 6
>>> test(2, 3, 10, 100)
2 10 3 100
\end{lstlisting}

Sometimes we might want to include some default arguments while excluding others. We do this by specifying which of the arguments we wish to pass a value to:

\begin{lstlisting}[style=ipython]
>>> def test(a=0, b=0, c=0, d=0):
...   print(a, b, c, d)
... 
>>> test(c=10)
0 0 10 0
>>> test(d=5, c=6)
0 0 6 5
\end{lstlisting}

\subsection{Recursion}
\label{subsec:recur}
Recursion is the idea of a function calling itself. This can be useful in a wide variety of situations, but it can also be easy to misuse. As an example, see this simple case of recursion:

\begin{lstlisting}[style=python]
def test():
    test()
\end{lstlisting}

If this function is called, it will continue to call itself infinitely until Python prints out an error message and quits. This is because the function calls itself every time it is called -- there is no case where the function ends without calling itself again. This case is called a base case, and it is important to include one in every recursive function. Here is a modified version of the above code that allows the initial call to specify a value limiting how many times the recursive call should be made:

\begin{lstlisting}[style=python]
def test(x):
    if x > 0:
        test(x - 1)
\end{lstlisting}

As an example of a more complex way of using recursion to solve a problem, here is an example of a recursive function that will sum a list where each element is either an integer or another list containing integers and lists:

\begin{lstlisting}[style=python]
def sum_lists(x):
    total = 0
    for i in x:
        if type(i) == int:
            total += i
        else:
            total += sum_lists(i)
    return total

data = [1, 2, [3, 4, [5, 6], 7], 8, 9]
print(sum_lists(data))
\end{lstlisting}

This program outputs \lstinline{45}, which is the sum of all the elements of the list, including all of the lists inside it. Notice that the base case in this function is if every element of the list passed to \lstinline{sum_lists} is an \lstinline{int}.

\section{First-class Functions}
\label{subsec:first}
In Python, functions are ``first-class citizens''. This means, essentially that they can be used in the same way as variables: they can be assigned to variables, passed to and returned from functions, and stored in data structures. As an example, here is a short program that stores functions inside of a list, then calls each one of those functions with the same argument.

\begin{lstlisting}[style=python]
def print_backwards(string):
    print(string[::-1])

def print_half(string):
    print(string[:len(string)//2])

def print_question(string):
    print("Why do you want me to print '{}'?".format(string))

print_functions = [print, print_backwards, print_half, print_question]

for func in print_functions:
    func("Hello, World!")
\end{lstlisting}

\begin{lstlisting}[style=bash]
Hello, World!
!dlroW ,olleH
Hello,
Why do you want me to print 'Hello, World!'?
\end{lstlisting}

\subsection{Map}
\label{subsec:map}
A common operation in Python is to call the same function for every element in a list, then create a new list with the results. Previously, we would have accomplished this with a \lstinline{for} loop:

\begin{lstlisting}[style=python]
def double(x):
    return x * 2

data = [5, 23, 76]
new_data = []

for i in data:
    new_data.append(double(i))

print(new_data)
\end{lstlisting}

\begin{lstlisting}[style=bash]
[10, 46, 152]
\end{lstlisting}

If we use the \lstinline{map} function, we can make this code much more simple:

\begin{lstlisting}[style=python]
def double(x):
    return x * 2

data = [5, 23, 76]
data = list(map(double, data))
print(data)
\end{lstlisting}

\begin{lstlisting}[style=bash]
[10, 46, 152]
\end{lstlisting}

The \lstinline{map} function takes in a function and any iterable data type (such as a list, tuple, set, etc.) as arguments. It calls that function for every element of the other value passed, then returns a new data type containing all of those results. This new data type is a special map object, but in most cases we are fine with instantly converting it back to our initial data type (in the above example, a list).

%List comprehensions?

%Reduce has been removed as of Python 3: https://docs.python.org/3.0/whatsnew/3.0.html#builtins
\subsection{Reduce}
\label{subsec:reduce}
\lstinline{reduce} is a similar function to \lstinline{map}, but rather than create a new list with the modified values, \lstinline{reduce} should be used to simplify a list into a single value. Similarly to \lstinline{map}, \lstinline{reduce} takes in a function and an iterable data type. The difference is that, rather than taking and returning a single value, the function passed to \lstinline{reduce} takes in two arguments and returns their combination. As an example, here is an example of using \lstinline{reduce} to join a list of strings into a single larger string.

\begin{lstlisting}[style=python]
import functools

def combine(glob, new):
    print("Adding {} to {}.".format(new, glob))
    return glob + new

data = ['this', 'is', 'a', 'test']
data = functools.reduce(combine, data)
print("Final value: {}".format(data))
\end{lstlisting}

Note that we need to run \lstinline{import functools} in order to have access to \lstinline{reduce}.

\subsection{Filter}
\label{subsec:filter}
\lstinline{filter} is a function that allows easy removal of some elements from a list. It works similarly to \lstinline{map}, but the function used needs to return either \lstinline{True} or \lstinline{False}. If it returns \lstinline{True} then the given element is included in the final list. If \lstinline{False} is returned, then it is not. As an example, here is a short program that removes all odd elements from a list:

\begin{lstlisting}[style=python]
def is_even(x):
    return x % 2 == 0

data = [5, 3, 34, 36, 38, 1, 0, 0, 2]
data = list(filter(is_even, data))
print(data)
\end{lstlisting}

\begin{lstlisting}[style=bash]
[34, 36, 38, 0, 0, 2]
\end{lstlisting}

\subsection{Lambda Functions}
\label{subsec:lambda}
Lambda functions are anonymous functions that are created while the program is running that are not assigned to a name like normal functions. They can be used very similarly to normal functions if assigned to a variable:

\begin{lstlisting}[style=ipython]
>>> def f(x):
...   return x + 1
... 
>>> g = lambda x: x + 1
>>> f(5)
6
>>> g(5)
6
\end{lstlisting}

In the above case, \lstinline{f} and \lstinline{g} are functionally equivalent. Both are functions that take in a single value and return that value increased by one. The primary difference is in syntax: note that the lambda function does not have a return statement: it will simply return the value computed after the colon.

Lambda functions are commonly used in conjunction with \lstinline{map}, \lstinline{reduce}, and \lstinline{filter} as shown below:

\begin{lstlisting}[style=python]
data = [5, 3, 34, 36, 38, 1, 0, 0, 2]
data = list(filter(lambda x: x % 2 == 0, data))
print(data)
\end{lstlisting}

\begin{lstlisting}[style=bash]
[34, 36, 38, 0, 0, 2]
\end{lstlisting}

This program works just like the example shown in the section on \lstinline{filter}, but it does not require us to declare the separate \lstinline{is_even} function. Instead, we simply define a lambda inside the call to \lstinline{filter}, accomplishing the same thing.


\pagebreak


%\pagebreak
\section{Exercises}
\label{sec:ex}

\begin{warningbox}{Boilerplate}
  Remember that this lab \emph{must} use the
  boilerplate syntax introduced in Lab~5, including the review exercises.
\end{warningbox}

\begin{description}
  \item[fractions2.py] Using the same tuple representation of fractions as least
    week, do the following:

    \begin{enumerate}
      \item Write a function \lstinline{min_frac} such that calling
        \lstinline{functools.reduce(min_frac, list_of_fractions)} will return
        the smallest value fraction in the list.
      \item Write a function \lstinline{sum_frac} such that calling
        \lstinline{functools.reduce(sum_frac, list_of_fractions)} will return
        the sum of all the fractions in the list.
      \item Write a function \lstinline{reduce_frac} that takes in a fraction and
        returns that fraction reduced to its lowest terms. Use this function with
        \lstinline{map} to reduce a list of fractions.
    \end{enumerate}
\end{description}

\pagebreak
\section{Submitting}

\begin{center}
  \textbf{We will be adding more exercises later. We have just not had the time
  to finish them. You will get an email about them.}
\end{center}

Files to submit:
\begin{itemize}
  \item fractions2.py (Section~\ref{sec:ex})
\end{itemize}

You may submit your code as either a tarball (instructions below) or as a .zip
file. Either one should contain all files used in the exercises for this lab.
The submitted file should be named either
\texttt{cse107\_firstname\_lastname\_lab8.zip} or
\texttt{cse107\_firstname\_lastname\_lab8.tar.gz} depending on which method you
used.

For Windows, use a tool you like to create a \texttt{.zip} file. The TCC
computers should have \texttt{7z} installed. For Linux, look at lab 1 for
instructions on how to create a tarball or use the ``Archive Manager'' graphical
tool.

\begin{center}
  \textbf{Upload your tarball or .zip file to Canvas.}
\end{center}

\end{document}
